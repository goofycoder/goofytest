------------------------------------------------------
I know it's a silly mistake, but DO NOT do the following:

set s;          // ERROR: should be  set<int> s;

int *b;     
b = new int[len];   
delete b[];     // ERROR: should be   delete[] b;


-------------------------------------------------------
HOW-TO:
    insert an integer char in front of a string.
    
    "abc" --> "1abc"?
    
    int d = 1;
    string str = "abc";
    
    str = (char)(d+'0') + str;      // the type conversion is mandatory! 


-----------------------------------------------------
XOR operation

    x^y = y^x;
    
    x^x = x;
    
    x^y^x = x^x^y = y


--------------------------------------------------------
bit operation
    - bitwise operators:  &  |  ~ ^
        NOTE: ! is not a bit operator, do NOT confuse it with ~
    
Example:
    ~1 = 0xfffffffe

----------------------------------------------------------
NULL ptr
    - C programmers must understand that NULL and 0 are interchangeable in pointer contexts.
    - address-of operator & will never yield a null pointer
    - guaranteed to compare unequal to a pointer to any object or function.
    
Example:
    int *p1 = NULL;
    int *p2 = NULL;
    
    if (p1 == p2)       // true, null ptrs are equal.
    

-------------------------------------------------------------
linked list insertion:

void insert_front(Node** phead, int data)           // Note: Node** phead;  because it would change the head ptr
{
    Node* n = new Node;
    
    n->data = data;
    n->next = next;
    
    if(*phead == NULL) {
        *phead = n;                     // linked in the new head;
        // phead = &n;                  // ERROR: it does not work!
        return;
    }
    
    ...
}

-----------------------------------------------------------
function pointer:

int (*fp)(int a, int b);   
// int *fp(int a, int b);       // note: this is different!
                                // this declares a function that returns int*, not the function pointer!

int foo(int a, int b) { return (a+b); }

fp = &foo;
// *fp = foo;              // won't compile!!!

int sum = (*fp)(a,b);      // sum = 5;


-----------------------------------------------------------
int *p = NULL;

int **pp = &p;                  // OK

if (pp == NULL)                 // false;

if (*pp == NULL)                // true;

--------------------------------------------------------
floating number:


float f = 0.1;
if(f==0.1)      // return false; because 0.1 is promoted to double from float.
                // the promotion of float to double can only cause mismatch 
                // when a value (like 0.1) uses more precision bits than the bits of single precision.
if(f==0.1f)     // return true;

float f2 = 0.5; 
if(f==0.5)      // return true;
if(f==0.5f)     // return 


------------------------------------------------------
void **ptr;
int size;

Q: reverse the memory ptr points to.


A: it is pointer to pointer. thus only reverse the ptr to memory, not memory itself.


for(int i=0; i<size/2; i++) 
{
  ptr[i] = ptr[size-i-1]
}

------------------------------------
sizeof(int) is not 32, it is 4.

--------------------------------------------
int arr[] = {2,1,3,5,4};
int len = sizeof(arr)/sizeof(int);    // OK, len = 5
int len = sizeof(arr)/sizeof(arr[0]); // OK, len = 5

-------------------------------------------
the keyword 'bool' is defined in <stdbool.h>

-------------------------------------------
INT_MAX is defined in <limits.h>

INT_MAX is 2^31-1
INT_MIN is -2^31+1
